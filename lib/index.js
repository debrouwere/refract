// Generated by CoffeeScript 1.8.0
(function() {
  var evaluate, extractKeys, interpolate, refract, requote, updateAt, utils, _,
    __slice = [].slice;

  _ = require('underscore');

  _.str = require('underscore.string');

  utils = require('./utils');

  evaluate = utils.evaluate, interpolate = utils.interpolate;


  /*
  Refract uses plain vanilla CoffeeScript for evaluating 
  refraction expressions, with two exceptions, encoded in
  the `requote` function.
  
  1. Single quotes are not interpolated in CoffeeScript, but 
  in a JSON file, "'an #{adjective} string'" looks much nicer 
  than "\"an #{adjective} string\"" so if we see single quotes, 
  we'll turn them into double quotes anyway.
   
  2. While /str/ denotes a regular expression in JavaScript, 
  this doesn't make much sense when refracting and instead
  probably denote some sort of file path, so we'll interpret 
  an expression that starts and ends with a forward slash
  as a string as well.
  
  Note that e.g. `/regexp/.exec 'some string'` and `fn 'a string'`
  will not be requoted, we're only checking the first and last 
  characters of the expressions.
   */

  requote = function(value) {
    var quoted, slashes;
    quoted = value.match(/^'.*'$/);
    slashes = value.match(/^\/.*\/$/);
    if (quoted) {
      return utils.string(value.slice(1, -1));
    } else if (slashes) {
      return utils.string(value);
    } else {
      return value;
    }
  };

  extractKeys = function(key) {
    var match, matches, namespace, rawKey, source, __;
    rawKey = key;
    match = key.match(/(\w+)(\[(\w+)(\:(\w+))?\])?/);
    matches = (_.compact(match)).length;
    if (matches > 5) {
      __ = match[0], key = match[1], __ = match[2], namespace = match[3], __ = match[4], source = match[5];
    } else {
      __ = match[0], key = match[1], __ = match[2], source = match[3];
      if (source == null) {
        source = key;
      }
      namespace = false;
    }
    return {
      rawKey: rawKey,
      key: key,
      namespace: namespace,
      source: source
    };
  };

  updateAt = function() {
    var key, obj, segment, segments, value, _i, _j, _len;
    obj = arguments[0], segments = 4 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 2) : (_i = 1, []), key = arguments[_i++], value = arguments[_i++];
    for (_j = 0, _len = segments.length; _j < _len; _j++) {
      segment = segments[_j];
      obj = obj[segment] != null ? obj[segment] : obj[segment] = {};
    }
    return _.extend(obj, utils.kv(key, value));
  };

  module.exports = refract = function(template, context, update) {
    var err, refractValue, refracted, value;
    if (update == null) {
      update = _.partial(updateAt, context);
    }
    switch (template != null ? template.constructor : void 0) {
      case Object:
        return _.object(_.map(template, function(value, key) {
          var i, iterationOptions, namespace, rawKey, refracted, source, subContext, subObj, subTemplate, updateHere, _i, _len, _ref, _ref1;
          if ((iterationOptions = key.slice(-1)) === ']') {
            rawKey = key;
            _ref = extractKeys(rawKey), key = _ref.key, namespace = _ref.namespace, source = _ref.source;
            subTemplate = template[rawKey];
            refracted = [];
            _ref1 = _.range(context[source].length);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              i = _ref1[_i];
              subObj = context[source][i];
              if (namespace) {
                subObj = utils.kv(namespace, subObj);
              }
              subContext = _.extend({}, context, subObj);
              refracted.push(refract(subTemplate, subContext));
            }
            update(key, refracted);
            return [key, refracted];
          } else {
            updateHere = _.partial(update, key);
            refracted = refract(value, context, updateHere);
            return [key, refracted];
          }
        }));
      case Array:
        refractValue = _.partial(refract, _, context, _.noop);
        refracted = _.map(template, refractValue);
        update(refracted);
        return refracted;
      case String:
        value = requote(template);
        try {
          refracted = evaluate(value, {
            sandbox: context
          });
        } catch (_error) {
          err = _error;
          refracted = interpolate(value, {
            sandbox: context
          });
        }
        update(refracted);
        return refracted;
      default:
        return template;
    }
  };

  module.exports.defaultHelpers = _.extend({
    refract: refract
  }, _, _.str);

}).call(this);
