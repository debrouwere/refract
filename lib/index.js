// Generated by CoffeeScript 1.8.0
(function() {
  var evaluate, interpolate, requote, updateAt, utils, _,
    __slice = [].slice;

  _ = require('underscore');

  _.str = require('underscore.string');

  utils = require('./utils');

  evaluate = utils.evaluate, interpolate = utils.interpolate;


  /*
  Refract uses plain vanilla CoffeeScript for evaluating 
  refraction expressions, with two exceptions, encoded in
  the `requote` function.
  
  1. Single quotes are not interpolated in CoffeeScript, but 
  in a JSON file, "'an #{adjective} string'" looks much nicer 
  than "\"an #{adjective} string\"" so if we see single quotes, 
  we'll turn them into double quotes anyway.
   
  2. While /str/ denotes a regular expression in JavaScript, 
  this doesn't make much sense when refracting and instead
  probably denote some sort of file path, so we'll interpret 
  an expression that starts and ends with a forward slash
  as a strings as well.
  
  Note that e.g. `/regexp/.exec 'some string'` and `fn 'a string'`
  will not be requoted, we're only checking the first and last 
  characters of the expressions.
   */

  requote = function(value) {
    var quoted, slashes;
    quoted = value.match(/^'.*'$/);
    slashes = value.match(/^\/.*\/$/);
    if (quoted) {
      return utils.string(value.slice(1, -1));
    } else if (slashes) {
      return utils.string(value);
    } else {
      return value;
    }
  };

  updateAt = function() {
    var key, obj, segment, segments, value, _i, _j, _len;
    obj = arguments[0], segments = 4 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 2) : (_i = 1, []), key = arguments[_i++], value = arguments[_i++];
    for (_j = 0, _len = segments.length; _j < _len; _j++) {
      segment = segments[_j];
      obj = obj[segment] != null ? obj[segment] : obj[segment] = {};
    }
    return _.extend(obj, utils.kv(key, value));
  };

  module.exports = function(template, context, update) {
    var err, refract, refracted, value;
    refract = _.partial(module.exports, _, context);
    if (update == null) {
      update = _.partial(updateAt, context);
    }
    switch (template.constructor) {
      case Object:
        return _.object(_.map(template, function(value, key) {
          var refracted, updateHere;
          updateHere = _.partial(update, key);
          refracted = refract(value, updateHere);
          return [key, refracted];
        }));
      case Array:
        return _.map(template, refract);
      default:
        value = requote(template);
        try {
          refracted = evaluate(value, {
            sandbox: context
          });
        } catch (_error) {
          err = _error;
          refracted = interpolate(value, {
            sandbox: context
          });
        }
        update(refracted);
        return refracted;
    }
  };

  module.exports.defaultHelpers = _.extend({}, _, _.str);

}).call(this);
