// Generated by CoffeeScript 1.8.0
(function() {
  var evaluate, interpolate, requote, updateAt, utils, _,
    __slice = [].slice;

  _ = require('underscore');

  _.str = require('underscore.string');

  utils = require('./utils');

  evaluate = utils.evaluate, interpolate = utils.interpolate;


  /*
  Refract uses plain vanilla CoffeeScript for evaluating 
  refraction expressions, with two exceptions, encoded in
  the `requote` function.
  
  1. Single quotes are not interpolated in CoffeeScript, but 
  in a JSON file, "'an #{adjective} string'" looks much nicer 
  than "\"an #{adjective} string\"" so if we see single quotes, 
  we'll turn them into double quotes anyway.
   
  2. While /str/ denotes a regular expression in JavaScript, 
  this doesn't make much sense when refracting and instead
  probably denote some sort of file path, so we'll interpret 
  an expression that starts and ends with a forward slash
  as a string as well.
  
  Note that e.g. `/regexp/.exec 'some string'` and `fn 'a string'`
  will not be requoted, we're only checking the first and last 
  characters of the expressions.
   */

  requote = function(value) {
    var quoted, slashes;
    quoted = value.match(/^'.*'$/);
    slashes = value.match(/^\/.*\/$/);
    if (quoted) {
      return utils.string(value.slice(1, -1));
    } else if (slashes) {
      return utils.string(value);
    } else {
      return value;
    }
  };

  updateAt = function() {
    var key, obj, segment, segments, value, _i, _j, _len;
    obj = arguments[0], segments = 4 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 2) : (_i = 1, []), key = arguments[_i++], value = arguments[_i++];
    for (_j = 0, _len = segments.length; _j < _len; _j++) {
      segment = segments[_j];
      obj = obj[segment] != null ? obj[segment] : obj[segment] = {};
    }
    return _.extend(obj, utils.kv(key, value));
  };

  module.exports = function(template, context, update) {
    var err, refract, refracted, value;
    refract = _.partial(module.exports, _, context);
    if (update == null) {
      update = _.partial(updateAt, context);
    }
    switch (template != null ? template.constructor : void 0) {
      case Object:
        return _.object(_.map(template, function(value, key) {
          var i, iterationOptions, rawKey, refracted, subobj, subtpl, updateHere, _context, _i, _len, _ref, _refract, _refracted;
          _refract = module.exports;
          if ((iterationOptions = key.slice(-2)) === '[]') {
            rawKey = key;
            key = key.slice(0, -2);
            refracted = [];
            _ref = _.range(context[key].length);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              i = _ref[_i];
              subtpl = template[rawKey];
              subobj = context[key][i];
              _context = _.extend({}, context, subobj);
              updateHere = _.partial(updateAt, _context);
              _refracted = _refract(subtpl, _context, updateHere);
              refracted.push(_refracted);
            }
            return [key, refracted];
          } else {
            updateHere = _.partial(update, key);
            refracted = refract(value, updateHere);
            return [key, refracted];
          }
        }));
      case Array:
        return _.map(template, refract);
      case String:
        value = requote(template);
        try {
          refracted = evaluate(value, {
            sandbox: context
          });
        } catch (_error) {
          err = _error;
          refracted = interpolate(value, {
            sandbox: context
          });
        }
        update(refracted);
        return refracted;
      default:
        return template;
    }
  };

  module.exports.defaultHelpers = _.extend({}, _, _.str, {
    refract: {
      module: exports
    }
  });

}).call(this);
