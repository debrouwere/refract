// Generated by CoffeeScript 1.8.0
(function() {
  var additionalHelpers, fs, helpers, inputExt, inputLocation, inputPath, merge, normalize, normalizedObjects, normalizer, objects, pairs, parse, parsers, program, rawInput, rawTemplate, refract, refractions, serialization, template, templateExt, utils, yaml, _;

  fs = require('fs');

  fs.path = require('path');

  _ = require('underscore');

  _.str = require('underscore.string');

  _.str.identity = _.identity;

  yaml = require('js-yaml');

  program = require('commander');

  refract = require('./');

  utils = require('./utils');

  parsers = {
    json: JSON.parse,
    yml: yaml.safeLoad,
    yaml: yaml.safeLoad,
    txt: _.identity
  };

  program.option('-t --template <path>', 'Path to a template file.').option('-s --string <template>', 'A template string.').option('-a --apply <mapping>', 'A mapping that specifies which function to apply to which field.').option('-u --update', 'Add refracted fields to the original object.').option('-m --missing', 'Only refract a field if it is not present in the original object.').option('-e --each', 'Refract each element in an array.').option('-H --helpers <path>', 'Add in additional JavaScript helper functions.').option('-N, --new', 'Refract an empty object.').option('-i --in-place', 'Modify the file that contains the original object.').option('-n --normalized <style>', 'Normalize field names to a standard style.', 'underscored').option('-I --indent [n]', 'Output pretty indented JSON.', parseInt, 2).parse(process.argv);

  if (program["new"]) {
    objects = [{}];
  } else {
    inputPath = program.args[0];
    inputLocation = inputPath || '/dev/stdin';
    inputExt = (fs.path.extname(inputLocation)).slice(1);
    parse = parsers[inputExt] || parsers.txt;
    rawInput = fs.readFileSync(fs.path.resolve(inputLocation), {
      encoding: 'utf8'
    });
    objects = parse(rawInput);
  }

  if (!program.each) {
    objects = [objects];
  }

  if (program.template) {
    rawTemplate = fs.readFileSync(fs.path.resolve(program.template), {
      encoding: 'utf8'
    });
    templateExt = (fs.path.extname(program.template)).slice(1);
    parse = parsers[templateExt];
    template = parse(rawTemplate);
  } else if (program.string) {
    template = yaml.safeLoad(program.string);
  } else if (program.apply) {
    template = _.object(program.apply).split(',').map(function(instruction) {
      return instruction.split(':');
    });
  } else {
    throw new Error("Specify a --template, --string string or --apply mapping.");
  }

  if (program.helpers) {
    require('coffee-script/register');
    additionalHelpers = require(fs.path.resolve(program.helpers));
  }

  helpers = _.extend({}, additionalHelpers, refract.defaultHelpers);

  if (program.normalized) {
    normalizer = _.str[program.normalized || 'identity'];
    normalize = _.partial(utils.applyToKeys, _, normalizer);
    normalizedObjects = _.map(objects, normalize);
  } else {
    normalizedObjects = objects;
  }

  refractions = _.map(normalizedObjects, function(item) {
    var context;
    context = _.extend({}, item, helpers);
    return refract(template, context);
  });

  if (program.missing || program.update) {
    if (program.missing) {
      merge = utils.splat(_.defaults);
    } else {
      merge = utils.splat(_.extend);
    }
    pairs = _.zip(normalizedObjects, refractions);
    refractions = _.map(pairs, merge);
  }

  if (!program.each) {
    refractions = refractions[0];
  }

  serialization = JSON.stringify(refractions, void 0, program.indent);

  if (refractions.constructor === String) {
    serialization = serialization.slice(1, -1);
  }

  if (program.inPlace) {
    if (!inputPath) {
      throw new Error("Cannot edit in-place on stdin.");
    }
    fs.writeFileSync(inputPath, serialization, {
      encoding: 'utf8'
    });
  } else {
    console.log(serialization);
  }

}).call(this);
