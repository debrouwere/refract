// Generated by CoffeeScript 1.8.0
(function() {
  var additionalHelpers, fs, helpers, inputPath, load, merge, normalize, normalizedObjects, normalizer, objects, pairs, program, refract, refractions, serialization, template, type, utils, _, _ref,
    __slice = [].slice;

  fs = require('fs');

  _ = require('underscore');

  _.str = require('underscore.string');

  _.str.identity = _.identity;

  program = require('commander');

  refract = require('./');

  load = require('./loader').load;

  utils = require('./utils');

  program.option('-t --template <path>', 'Path to a template file.').option('-s --string <template>', 'Interpolate a string, in lieu of using a template.').option('-T --template-string <template>', 'Describe a YAML template on the command-line.').option('-a --apply <mapping>', 'A mapping that specifies which function to apply to which field.').option('-u --update', 'Add refracted fields to the original object.').option('-m --missing', 'Only refract a field if it is not present in the original object.').option('-e --each', 'Refract each element in an array.').option('-H --helpers <path>', 'Add in additional JavaScript helper functions and data.').option('-N, --new', 'Refract an empty object.').option('-i --in-place', 'Modify the file that contains the original object.').option('-n --normalized <style>', 'Normalize field names to a standard style.', 'underscored').option('-I --indent [n]', 'Output pretty indented JSON.', parseInt, 2).parse(process.argv);

  if (program["new"]) {
    objects = [{}];
  } else {
    inputPath = program.args[0];
    if (!inputPath) {
      inputPath = '/dev/stdin';
      type = 'yaml';
    }
    objects = load(inputPath, {
      type: type
    });
  }

  if (!program.each) {
    objects = [objects];
  }

  if (program.template) {
    template = load(program.template);
  } else if (program.string) {
    template = program.string;
  } else if (program.templateString) {
    template = yaml.safeLoad(program.string);
  } else if (program.apply) {
    template = _.object(program.apply).split(',').map(function(instruction) {
      return instruction.split(':');
    });
  } else {
    throw new Error("Specify a --template, --string, --template-string or --apply mapping.");
  }

  additionalHelpers = (((_ref = program.helpers) != null ? _ref.split(',') : void 0) || []).map(function(path) {
    return load(path, {
      namespace: true
    });
  });

  helpers = _.extend.apply(_, [{}].concat(__slice.call(additionalHelpers), [refract.defaultHelpers]));

  if (program.normalized) {
    normalizer = _.str[program.normalized || 'identity'];
    normalize = _.partial(utils.applyToKeys, _, normalizer);
    normalizedObjects = _.map(objects, normalize);
  } else {
    normalizedObjects = objects;
  }

  refractions = _.map(normalizedObjects, function(item) {
    var context;
    context = _.extend({}, item, helpers);
    return refract(template, context);
  });

  if (program.missing || program.update) {
    if (program.missing) {
      merge = utils.splat(_.defaults);
    } else {
      merge = utils.splat(_.extend);
    }
    pairs = _.zip(normalizedObjects, refractions);
    refractions = _.map(pairs, merge);
  }

  if (!program.each) {
    refractions = refractions[0];
  }

  serialization = JSON.stringify(refractions, void 0, program.indent);

  if (refractions.constructor === String) {
    serialization = serialization.slice(1, -1);
  }

  if (program.inPlace) {
    if (!inputPath) {
      throw new Error("Cannot edit in-place on stdin.");
    }
    fs.writeFileSync(inputPath, serialization, {
      encoding: 'utf8'
    });
  } else {
    console.log(serialization);
  }

}).call(this);
